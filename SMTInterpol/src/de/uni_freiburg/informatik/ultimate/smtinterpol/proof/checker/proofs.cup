/*
 * Copyright (C) 2009-2012 University of Freiburg
 *
 * This file is part of SMTInterpol.
 *
 * SMTInterpol is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * SMTInterpol is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SMTInterpol.  If not, see <http://www.gnu.org/licenses/>.
 */
/* CUP specification for proofs */

package de.uni_freiburg.informatik.ultimate.smtinterpol.proof.checker;
import de.uni_freiburg.informatik.ultimate.logic.*;
import de.uni_freiburg.informatik.ultimate.smtinterpol.proof.ProofLiteral;
import de.uni_freiburg.informatik.ultimate.smtinterpol.proof.ProofRules;
import de.uni_freiburg.informatik.ultimate.util.datastructures.ScopedHashMap;
import java.math.BigInteger;
import java.math.BigDecimal;
import java.util.Arrays;
import com.github.jhoenicke.javacup.runtime.Symbol;
import com.github.jhoenicke.javacup.runtime.SimpleSymbolFactory;
import java.util.Map;

parser ProofParser;
option symbols = ProofSymbols;
option java15, compact_red, newpositions;

parser code {:
	String filename;
	ParseEnvironment env;

	public static final Sort[] EMPTY_SORT_ARRAY = {};

	public Script getScript() {
	}

	public ProofRules getProofRules() {
	}

	public void report_error(String s, Object sym) {
		String location;
		if (sym instanceof SimpleSymbolFactory.LineColumnSymbol) {
			SimpleSymbolFactory.LineColumnSymbol bsym = (SimpleSymbolFactory.LineColumnSymbol) sym;
			location = bsym.getLocation();
		} else if ((sym instanceof Symbol)
				   && ((Symbol)sym).sym == LexerSymbols.EOF) {
			location = "EOF";
		} else
			location = "UNKNOWN";

		action_obj.setError(filename+":"+location+": "+s);
	}

	public void report_error(String s) {
		report_error(s, cur_token);
	}

	public void syntax_error(Symbol sym) {
		report_error("Syntax Error", sym);
		env.printError(action_obj.getError());
	}

	public void setFileName(String filename) {
		this.filename = filename;
	}

	public void setParseEnvironment(ParseEnvironment env) {
		this.env = env;
	}
:}

action code {:
	ScopedHashMap<String,TermVariable> localVars =
		new ScopedHashMap<String, TermVariable>(false);
	Sort[] mSortParams = null;
	static Sort[] emptySortArray = new Sort[0];
	Sort mMatchSort = null;

	static class Binding {
		TermVariable mVar;
		Term mTerm;
		public Binding(TermVariable var, Term term) {
			mVar = var;
			mTerm = term;
		}
		TermVariable getVar() {
			return mVar;
		}
		Term getTerm() {
			return mTerm;
		}
	}

	static class IndexedIdentifier {
		String mName;
		String[] mIndices;
		public IndexedIdentifier(String name, String[] indices) {
			mName = name;
			mIndices = indices;
		}
		public String getName() {
			return mName;
		}
		public String[] getIndices() {
			return mIndices;
		}

		public String toString() {
			if (mIndices == null)
				return mName;
			return "(_ "+mName+" "+Arrays.toString(mIndices)+")";
		}
	}

	static class QualIdentifier {
		String mName;
		String[] mIndices;
		Sort mSort;
		public QualIdentifier(IndexedIdentifier id, Sort sort) {
			mName = id.getName();
			mIndices = id.getIndices();
			mSort = sort;
		}
		public String getIdentifier() {
			return mName;
		}
		public String[] getIndices() {
			return mIndices;
		}
		public Sort getSort() {
			return mSort;
		}

		public String toString() {
			String indexedId;
			if (mIndices == null)
				indexedId = mName;
			else
				indexedId = "(_ "+mName+" "+Arrays.toString(mIndices)+")";
			if (mSort == null)
				return indexedId;
			return "(as " + indexedId + " " + mSort + ")";
		}
	}

	static class SelectorDec {
		String mSelector;
		Sort mArgumentSort;
		public SelectorDec(String selector, Sort argumentSort) {
			mSelector = selector;
			mArgumentSort = argumentSort; 
		}
		public String getSelector() {
			return mSelector;
		}
		public Sort getArgumentSort() {
			return mArgumentSort;
		}
		public String toString() {
			return "(" + mSelector + " " + mArgumentSort + ")";
		}
	}

	static class ParametricConstructors {
		final DataType.Constructor[] mConstructors;
		final Sort[] mSortParams;
		public ParametricConstructors(DataType.Constructor[] constructors) {
			mConstructors = constructors;
			mSortParams = null;
		}
		public ParametricConstructors(DataType.Constructor[] constructors, Sort[] sortparams) {
			mConstructors = constructors;
			mSortParams = sortparams;
		}
		public DataType.Constructor[] getConstructors() {
			return mConstructors;
		}
		public Sort[] getSortParams() {
			return mSortParams;
		}
	}

	class Pattern {
		DataType.Constructor mConstructor;
		TermVariable[] mVars;
		Sort[] mSorts;

		public Pattern(String constructor, String[] vars) {
			for (int i = 0; i < vars.length; i++) {
				for (int j = 0; j < i; j++) {
					if (vars[j].equals(vars[i])) {
						throw new SMTLIBException("Variables must all be distinct.");
					}
				}
			}

			DataType dataType = (DataType) mMatchSort.getSortSymbol();
			mConstructor = dataType.findConstructor(constructor);
			if (mConstructor == null) {
				throw new SMTLIBException("Constructor not found.");
			}
			mSorts = mConstructor.getArgumentSorts();
			mVars = new TermVariable[vars.length];
			if (mSorts.length != mVars.length) {
				throw new SMTLIBException("Number of constructor arguments does not match.");
			}

			for (int i = 0; i < vars.length; i++) {
				Sort sort = mSorts[i].mapSort(mMatchSort.getArguments());
				mVars[i] = createTermVariable(vars[i], sort);
			}
		}

		public Pattern(String constructor) {
			mConstructor = ((DataType) mMatchSort.getSortSymbol()).findConstructor(constructor);
			if (mConstructor == null) {
				mVars = new TermVariable[1];
				mVars[0] = createTermVariable(constructor, mMatchSort);
			} else {
				mVars = new TermVariable[0];
				if (mConstructor.getArgumentSorts().length != 0) {
					throw new SMTLIBException("Number of constructor arguments does not match.");
				}
			}
		}

		public TermVariable[] getVars() {
			return mVars;
		}

		public DataType.Constructor getConstructor() {
			return mConstructor;
		}

		public String toString() {
			if (mConstructor == null) {
				return mVars[0].toString();
			} else {
				StringBuilder sb = new StringBuilder();
				sb.append('('). append(mConstructor.getName());
				for (TermVariable tv : mVars) {
					sb.append(' ').append(tv);
				}
				sb.append(')');
				return sb.toString();
			}
		}
	}

	static class MatchCase {
		Pattern mPattern;
		Term mCase;

		public MatchCase(Pattern pattern, Term caseTerm) {
			mPattern = pattern;
			mCase = caseTerm;
		}

		public Pattern getPattern() {
			return mPattern;
		}

		public Term getCase() {
			return mCase;
		}

		public String toString() {
			return "(" + mPattern + " " + mCase + ")";
		}
	}

	Term createMatchTerm (Symbol sym, Term dataArg, MatchCase[] matchCases) {
		/* first check if some argument is null.  In this case we already reported an error and should return null. */
		if (mMatchSort == null) {
			return null;
		}
		for (MatchCase matchCase : matchCases) {
			if (matchCase == null) {
				return null;
			}
		}
		DataType matchDatatype = (DataType) mMatchSort.getSortSymbol();
		if (!checkPatterns(matchDatatype, matchCases)) {
			parser.report_error("Either match term contains a pattern consisting of a variable or all constructors must occur in one of the patterns.", sym);
			return null;
		}
		TermVariable[][] vars = new TermVariable[matchCases.length][];
		Term[] cases = new Term[matchCases.length];
		DataType.Constructor[] constructors = new DataType.Constructor[matchCases.length];
		for (int i = 0; i < matchCases.length; i++) {
			vars[i] = matchCases[i].getPattern().getVars();
			cases[i] = matchCases[i].getCase();
			constructors[i] = matchCases[i].getPattern().getConstructor();
		}
		return parser.getScript().match(dataArg, vars, cases, constructors);
	}

	// Function to check that either match term contains a pattern consisting of a variable
	// or all constructors must occur in one of the patterns.
	public boolean checkPatterns(DataType matchDatatype, MatchCase[] matchCases) {
		for (int i = 0; i < matchCases.length; i++) {
			if (matchCases[i].getPattern().getConstructor() == null) {
				return true;
			}
		}
		DataType.Constructor[] allConstrs = matchDatatype.getConstructors();
		for (int i = 0; i < allConstrs.length; i++) {
			boolean constrFound = false;
			for (int j = 0; j < matchCases.length; j++) {
				if (matchCases[j].getPattern().getConstructor().getName().equals(allConstrs[i].getName())) {
					constrFound = true;
				}
			}
			if (!constrFound) {
				return false;
			}
		}
		return true;
	}

	String errorMessage;
	public void setError(String message) {
		if (errorMessage == null)
			errorMessage = message;
	}
	public boolean hasError() {
		return errorMessage != null;
	}
	public String getError() {
		String result = errorMessage;
		errorMessage = null;
		return result;
	}

	private Sort[] getSortParams() {
		return mSortParams;
	}

	private void pushSortParams(String[] sortVars) {
		assert mSortParams == null;
		mSortParams = parser.getScript().sortVariables(sortVars);
	}

	private void popSortParams() {
		assert mSortParams != null;
		mSortParams = null;
	}

	public Sort lookupSort(Symbol sym, IndexedIdentifier id, Sort[] args) {
		for (Sort s: args) {
			if (s == null) return null;
		}
		String name = id.getName();
		if (args.length == 0 && id.getIndices() == null && mSortParams != null) {
			for (Sort s: mSortParams) {
				if (s.getName().equals(name))
					return s;
			}
		}
		try {
			return parser.getScript().sort(name, id.getIndices(), args);
		} catch (SMTLIBException se) {
			parser.report_error("Undeclared sort ("+id+" "+args.length+")", sym);
		}
		return null;
	}

	public Term createTerm(Symbol fsym, String name, String[] indices, Sort resultSort, Term[] param) {
		// check if there was an error when creating the child term.
		for (Term p : param) {
			if (p == null)
				return null;
		}
		try {
			return parser.getScript().term(name, indices, resultSort, param);
		} catch (SMTLIBException se) {
			parser.report_error(se.getMessage(), fsym);
		}
		return null;
	}

	public TermVariable createTermVariable(String name, Sort sort) {
		if (sort == null)
			return null;
		try {
			TermVariable tv = parser.getScript().variable(name, sort);
			localVars.put(tv.getName(), tv);
			return tv;
		} catch (SMTLIBException cannotHappen) {}
		// Actually unreachable
		throw new AssertionError();
	}

	private Term getTermVariable(String name) {
		return localVars.get(name);
	}

	public Term annotateTerm(Term term, Annotation[] annots) {
		if (term == null)
			return null;
		try {
			return parser.getScript().annotate(term, annots);
		} catch (SMTLIBException se) {
			parser.report_error(se.getMessage());
		}
		return null;
	}

	public void beginFunction(String funcName, Sort[] paramSorts, Sort resultSort) {
		parser.getScript().push(1);
		parser.getScript().getTheory().declareInternalFunction(funcName, paramSorts, resultSort, 0);
	}

	public Term defineFun(String funcName, TermVariable[] vars, Term definition, Term subProof) {
		Theory theory = parser.getScript().getTheory();
		FunctionSymbol funcSym = theory.getFunctionSymbol(funcName);
		parser.getScript().pop(1);
		return parser.getProofRules().defineFun(funcSym, theory.lambda(vars, definition), subProof);
	}

	public Term declareFun(String funcName, Sort[] paramSorts, Sort resultSort, Term subProof) {
		Theory theory = parser.getScript().getTheory();
		FunctionSymbol funcSym = theory.getFunctionSymbol(funcName);
		parser.getScript().pop(1);
		return parser.getProofRules().declareFun(funcSym, subProof);
	}
:}

/*init with {: getScanner().init(); :} */
scan with {: return getScanner().next_token(); :}


/* Predefined Symbols */
terminal String UNDERSCORE, BANG,
         AS, CHOOSE, EXISTS, FORALL, LET, MATCH,
         PLUS, MINUS,
         ASSUME, RES, LETPROOF, ORACLE, DECLAREFUN, DEFINEFUN, PAR,
         FALSEE, TRUEI, NOTI, NOTE, ORI, ORE, ANDI, ANDE, IMPI, IMPE,
         IFFI1, IFFI2, IFFE1, IFFE2, XORI, XORE, FORALLI, FORALLE, EXISTSI, EXISTSE,
         EQI, EQE, DISTINCTI, DISTINCTE, ITE1, ITE2, REFL, SYMM, TRANS, CONG, EXPAND, DELANNOT,
         DIVISIBLEDEF, GTDEF, GEQDEF, TRICHOTOMY, TOTAL, TOTALINT, FARKAS, TOINTHIGH, TOINTLOW,
         MINUSDEF, DIVIDEDEF, POLYADD, POLYMUL, TOREALDEF, DIVLOW, DIVHIGH, MODDEF,
         SELECTSTORE1, SELECTSTORE2, EXTDIFF, CONST,
         DT_PROJECT, DT_CONS, DT_TESTI, DT_TESTE, DT_EXHAUST, DT_ACYCLIC, DT_MATCH;

/* Predefined Keywords */
terminal String /* attribute */
         CNAMED, CPATTERN;
terminal String SYMBOL, KEYWORD;
terminal BigInteger NUMERAL;
terminal BigDecimal DECIMAL;
terminal String HEXADECIMAL, BINARY, STRING;
terminal LPAR, RPAR;

non terminal String keyword, symbol, allsymbol;
non terminal String keywordAttr;
non terminal String keywordNoAttr;
non terminal String index;
non terminal IndexedIdentifier identifier, identifierIndexed;
non terminal Object specConstant;
non terminal Object sExpr;
non terminal QuotedObject string;

non terminal Sort sort;
non terminal Object attributeValue;
non terminal Annotation attribute;
non terminal QualIdentifier qualIdentifier;
non terminal Binding varBinding, varBindingProof;
non terminal Binding[] letfront;
non terminal TermVariable sortedVar;
non terminal Pattern pattern;
non terminal MatchCase matchCase;
non terminal Term constantTerm, term, proof, axiom;
non terminal ProofLiteral literal;
non terminal Term goal;

goal ::= symbol proof:p {: RESULT = p; :};

string ::= STRING:n {: RESULT = new QuotedObject(n, true); :};

specConstant ::= NUMERAL
             | DECIMAL
             | HEXADECIMAL
             | BINARY
             | string;
sExpr ::= specConstant
        | allsymbol
        | KEYWORD
        | LPAR sExpr*:s RPAR {: RESULT = s; :};

constantTerm ::= NUMERAL:n
                {: try {
                       RESULT = parser.getScript().numeral(n);
                   } catch (SMTLIBException se) {
                       parser.report_error(se.getMessage());
                       RESULT = null;
                   } :}
             | DECIMAL:n
                 {: try {
                        RESULT = parser.getScript().decimal(n);
                    } catch (SMTLIBException se) {
                        parser.report_error(se.getMessage());
                        RESULT = null;
                    } :}
             | HEXADECIMAL:n {: try {
                        RESULT = parser.getScript().hexadecimal(n);
                    } catch (SMTLIBException se) {
                        parser.report_error(se.getMessage());
                        RESULT = null;
                    }  :}
             | BINARY:n {: try {
                        RESULT = parser.getScript().binary(n);
                    } catch (SMTLIBException se) {
                        parser.report_error(se.getMessage());
                        RESULT = null;
                    } :}
             | string:n {: try {
                        RESULT = parser.getScript().string(n);
                    } catch (SMTLIBException se) {
                        parser.report_error(se.getMessage());
                        RESULT = null;
                    } :};
index ::= NUMERAL:n {: RESULT = n.toString(); :} | symbol | HEXADECIMAL | BINARY;
identifierIndexed ::= LPAR UNDERSCORE symbol:id index+:indices RPAR
             {: RESULT = new IndexedIdentifier(id, indices); :};
identifier ::= symbol:s {: RESULT = new IndexedIdentifier(s, null); :}
           | identifierIndexed;

sort ::= identifier:id {: RESULT = lookupSort(id$, id, emptySortArray); :}
       | LPAR identifier:id sort+:sorts RPAR
         {: RESULT = lookupSort(id$, id, sorts); :};
attribute ::= keywordNoAttr:k attributeValue?:v {: RESULT = new Annotation(k, v); :}
        | CNAMED:k symbol:v {: RESULT = new Annotation(k, v); :}
        | CPATTERN:k LPAR term*:t RPAR {: RESULT = new Annotation(k, t); :};
attributeValue ::= specConstant
        | symbol
        | LPAR sExpr*:s RPAR {: RESULT = s; :};

qualIdentifier ::= identifier:i
         {: RESULT = new QualIdentifier(i, null); :}
       | LPAR AS identifier:i sort:s RPAR
         {: RESULT = new QualIdentifier(i, s); :};
varBinding ::= LPAR symbol:sym term:t RPAR
         {: if (hasError()) {
                RESULT = null;
            } else {
                TermVariable tv = createTermVariable(sym, t.getSort());
                RESULT = new Binding(tv, t);
            }
          :};
sortedVar ::= LPAR symbol:sym sort:s RPAR
         {: RESULT = createTermVariable(sym, s); :};
pattern ::= symbol:sym
         {: if (mMatchSort == null) {
                RESULT = null;
            } else {
                try {
                    RESULT = new Pattern(sym);
                } catch (SMTLIBException ex) {
                    parser.report_error(ex.getMessage(), sym$);
                    RESULT = null;
                }
            }
         :}
       | LPAR symbol:constr symbol+:vars RPAR
         {: if (mMatchSort == null) {
                RESULT = null;
            } else {
                try {
                    RESULT = new Pattern(constr, vars);
                } catch (SMTLIBException ex) {
                    parser.report_error(ex.getMessage(), constr$);
                    RESULT = null;
                }
            }
         :};
matchCase ::= LPAR {: localVars.beginScope(); :} pattern:p term:t RPAR
         {:
            localVars.endScope();
            if (p != null && t != null) {
                RESULT = new MatchCase(p, t);
            }
         :};
term ::= constantTerm
       | qualIdentifier:fun
         {: RESULT = fun.getIndices() == null && fun.getSort() == null ? getTermVariable(fun.getIdentifier()) : null;
            if (RESULT == null)
                RESULT = createTerm(fun$, fun.getIdentifier(), fun.getIndices(), fun.getSort(), new Term[0]); :}
       | LPAR qualIdentifier:fun term+:args RPAR
         {: RESULT = createTerm(fun$, fun.getIdentifier(), fun.getIndices(), fun.getSort(), args); :}
       | LPAR LET {: localVars.beginScope(); :}
                  LPAR varBinding+:bindings RPAR term:t RPAR
         {: TermVariable[] vars = new TermVariable[bindings.length];
            Term[] terms = new Term[bindings.length];
            for (int i = 0; i < bindings.length; i++) {
                if (bindings[i] != null) {
                    vars[i] = bindings[i].getVar();
                    terms[i] = bindings[i].getTerm();
                }
            }
            localVars.endScope();
            if (hasError())
                RESULT = null;
            else
                RESULT = parser.getScript().let(vars, terms, t); :}
       | LPAR CHOOSE:sym {: localVars.beginScope(); :}
              sortedVar:var term:t RPAR
         {: localVars.endScope();
               RESULT = null;
            try {
                if (!hasError())
                    RESULT = parser.getProofRules().choose(var, t);
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage(), sym$);
            } :}
       | LPAR FORALL:sym {: localVars.beginScope(); :}
              LPAR sortedVar+:vars RPAR term:t RPAR
         {: localVars.endScope();
               RESULT = null;
            try {
                if (!hasError())
                    RESULT = parser.getScript().quantifier(Script.FORALL, vars, t);
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage(), sym$);
            } :}
       | LPAR EXISTS:sym {: localVars.beginScope(); :}
              LPAR sortedVar+:vars RPAR term:t RPAR
         {: localVars.endScope();
               RESULT = null;
            try {
                if (!hasError()) {
                    RESULT = parser.getScript().quantifier(Script.EXISTS, vars, t);
                }
            } catch (SMTLIBException se) {
                parser.report_error(se.getMessage(), sym$);
            } :}
       | LPAR MATCH:sym 
            term:dataArg
         {:
            if (dataArg != null) {
                mMatchSort = dataArg.getSort();
                if (!mMatchSort.getSortSymbol().isDatatype()) {
                    parser.report_error("Match term must be of a datatype sort.", sym$);
                    mMatchSort = null;
                }
            } :}
            LPAR matchCase+:matchCases RPAR RPAR
         {:
            RESULT = createMatchTerm(sym$, dataArg, matchCases);
            mMatchSort = null;
         :}
       | LPAR BANG term:t attribute+:attr RPAR
         {: RESULT = annotateTerm(t, attr); :};

varBindingProof ::= LPAR symbol:sym proof:t RPAR
         {: if (hasError()) {
                RESULT = null;
            } else {
                TermVariable tv = createTermVariable(sym, t.getSort());
                RESULT = new Binding(tv, t);
            }
          :};

axiom ::= FALSEE {: RESULT = parser.getProofRules().falseElim(); :}
        | TRUEI {: RESULT = parser.getProofRules().trueIntro(); :}
        | NOTI term:t {: RESULT = parser.getProofRules().notIntro(t); :}
        | NOTE term:t {: RESULT = parser.getProofRules().notElim(t); :}
        | ORI NUMERAL:n term*:t {: RESULT = parser.getProofRules().orIntro(n.intValue(), parser.getScript().term(SMTLIBConstants.OR, t)); :}
        | ORE term*:t {: RESULT = parser.getProofRules().orElim(parser.getScript().term(SMTLIBConstants.OR, t)); :}
        | IMPI NUMERAL:n term*:t {: RESULT = parser.getProofRules().impIntro(n.intValue(), parser.getScript().term(SMTLIBConstants.IMPLIES, t)); :}
        | IMPE term*:t {: RESULT = parser.getProofRules().impElim(parser.getScript().term(SMTLIBConstants.IMPLIES, t)); :}
        | ANDI term*:t {: RESULT = parser.getProofRules().andIntro(parser.getScript().term(SMTLIBConstants.AND, t)); :}
        | ANDE NUMERAL:n term*:t {: RESULT = parser.getProofRules().andElim(n.intValue(), parser.getScript().term(SMTLIBConstants.AND, t)); :};

literal ::= PLUS term:t {: RESULT = new ProofLiteral(t, true); :}
          | MINUS term:t {: RESULT = new ProofLiteral(t, false); :};

letfront ::= LPAR LET {: localVars.beginScope(); :}
                  LPAR varBinding+:bindings RPAR
                  {: RESULT = bindings; :}
          | LPAR LETPROOF {: localVars.beginScope(); :}
                  LPAR varBindingProof+:bindings RPAR
                  {: RESULT = bindings; :};

proof ::= LPAR axiom:ax RPAR {: RESULT = ax; :}
        | LPAR ASSUME term:assertion RPAR {: RESULT = parser.getProofRules().asserted(assertion); :}
        | LPAR RES term:pivot proof:lhs proof:rhs
          {: RESULT = parser.getProofRules().resolutionRule(pivot, lhs, rhs); :}
        | symbol:var
         {: RESULT = getTermVariable(var);
            if (RESULT == null) {
                parser.report_error("Undeclared proof variable");
            }
          :}
        | letfront:bindings proof:t RPAR
         {: TermVariable[] vars = new TermVariable[bindings.length];
            Term[] terms = new Term[bindings.length];
            for (int i = 0; i < bindings.length; i++) {
                if (bindings[i] != null) {
                    vars[i] = bindings[i].getVar();
                    terms[i] = bindings[i].getTerm();
                }
            }
            localVars.endScope();
            if (hasError())
                RESULT = null;
            else
                RESULT = parser.getScript().let(vars, terms, t); :}
        | LPAR DEFINEFUN symbol:fun LPAR sortedVar*:vars RPAR term:definition
          {: Sort[] varSorts = new Sort[vars.length];
             for (int i = 0; i < vars.length; i++) {
                 varSorts[i] = vars[i].getSort();
             }
             beginFunction(fun, varSorts, definition.getSort()); :}
             proof:subproof RPAR
          {: RESULT = defineFun(fun, vars, definition, subproof); :}
        | LPAR DECLAREFUN symbol:fun LPAR sort*:param RPAR sort:result
          {: beginFunction(fun, param, result); :}
             proof:subproof RPAR
          {: RESULT = declareFun(fun, param, result, subproof); :}
        | LPAR ORACLE literal*:lits attribute*:attribs RPAR
          {: RESULT = parser.getProofRules().oracle(lits, attribs); :};

symbol ::= SYMBOL
         | PLUS | MINUS
         | ASSUME | RES | LETPROOF | ORACLE | DECLAREFUN | DEFINEFUN
         | FALSEE | TRUEI | NOTI | NOTE | ORI | ORE | ANDI | ANDE | IMPI | IMPE
         | IFFI1 | IFFI2 | IFFE1 | IFFE2 | XORI | XORE | FORALLI | FORALLE | EXISTSI | EXISTSE
         | EQI | EQE | DISTINCTI | DISTINCTE | ITE1 | ITE2 | REFL | SYMM | TRANS | CONG | EXPAND | DELANNOT
         | DIVISIBLEDEF | GTDEF | GEQDEF | TRICHOTOMY | TOTAL | TOTALINT | FARKAS | TOINTHIGH | TOINTLOW
         | MINUSDEF | DIVIDEDEF | POLYADD | POLYMUL | TOREALDEF | DIVLOW | DIVHIGH | MODDEF
         | SELECTSTORE1 | SELECTSTORE2 | EXTDIFF | CONST
         | DT_PROJECT | DT_CONS | DT_TESTI | DT_TESTE | DT_EXHAUST | DT_ACYCLIC | DT_MATCH;

/* The following are reserved words and are only allowed in sexpr. */
allsymbol ::= symbol | PAR | UNDERSCORE | AS | BANG | CHOOSE | LET | FORALL | EXISTS | MATCH;

keywordAttr   ::= CPATTERN | CNAMED;
keywordNoAttr ::= KEYWORD;
keyword ::= KEYWORD | keywordAttr;
